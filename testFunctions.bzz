# Use Shift + Click to select a robot
# When a robot is selected, its variables appear in this editor

# Use Ctrl + Click (Cmd + Click on Mac) to move a selected robot to a different location
include "/home/arsalan/buzz/src/include/vec2.bzz"

function goToGlobal2DPoint(point){
	log ("Reached Global2DPoint function")
	# Enter here if not within a certain thereshold of point to be reached.

	if (point.x < pose.position.x - 0.01 or point.x > pose.position.x + 0.01 or point.y < pose.position.y - 0.01 or point.y > pose.position.y + 0.01){

		# First, Orient itself towards the point
		if (orientToGlobal2DPoint(point) == 1) {	# If it has oriented itself
		# Move towards the point of interest
		# create a new polar vector.. Ask to go in straight direction
			straightHeading = math.vec2.newp(10, 0)
			goto(straightHeading.x, straightHeading.y)
			log ("Going Straight Now")
		}
		else orientToGlobal2DPoint(point)
	}
	else {
		log ("Reached Destination Point")
		goto(0.0, 0.0) # Make the velocity 0 so that the robot does not move without any reason
	}
}

function orientToGlobal2DPoint(point) {	
	orientationDoneFlag = 0
# Compute the angle from current location to goto location
	angleToGlobal2DPoint =  math.atan(point.y - pose.position.y, point.x - pose.position.x)
	log (angleToGlobal2DPoint)
# Orient the robot towards that point, by giving it a generic velocity vector of linear velocity 1
# and angular velocity math.pi
# The first if seems kind of unnecessary.. the threshold added here.. but it should be a corner case
	if (pose.orientation.yaw < angleToGlobal2DPoint - 0.01 or pose.orientation.yaw > angleToGlobal2DPoint + 0.01){
		if (pose.orientation.yaw < angleToGlobal2DPoint){
			log("In < part")
			#orientVelcoityVector = math.vec2.newp(0.1, math.pi)
			#log (orientVelcoityVector.x, " ", orientVelcoityVector.y)
			#goto (orientVelcoityVector.x, orientVelcoityVector.y)
			set_wheels(-1.0,1.0)
		}
		else if (pose.orientation.yaw > angleToGlobal2DPoint){
			log("In > part")
			#orientVelcoityVector = math.vec2.newp(0.000, -math.pi/2)
			#log (orientVelcoityVector.x, " ", orientVelcoityVector.y)
			#goto (orientVelcoityVector.x, orientVelcoityVector.y)
			set_wheels(1.0,-1.0)
		}
		else log ("Orientation done")
	}
  else { 
		log ("Already oriented")
		orientationDoneFlag = 1
		#set_wheels(0.0, 0.0)					# So that it stops orienting itself once into right orientation
	}
return orientationDoneFlag
}


# This function is executed every time you press the 'execute' button
function init() {
   # put your code here
	log("Robot: ", id, " initialized!")

}



# This function is executed at each time step
# It must contain the logic of your controller
function step() {
   # put your code here
	if (id == 1){
		log ("Robot", id, " x: ",pose.position.x )
		log ("Robot", id, " y: ",pose.position.y )
		log ("Robot", id, " Roll: ", pose.orientation.roll)
		log ("Robot", id, " Pitch: ", pose.orientation.pitch)
		log ("Robot", id, " Yaw: ", pose.orientation.yaw)

		#if (pose.orientation.yaw <= )
#		result = math.vec2.newp(1, -math.pi)

#		goto (result.x, result.y)
  		point = {}
  		point.x = 0.0
		point.y = 0.0
		goToGlobal2DPoint(point)
	}

#	goto (0, 1)
#	set_wheels(5.0,5.0)
# Transformation
}



# This function is executed every time you press the 'reset'
# button in the GUI. It is supposed to restore the state
# of the controller to whatever it was right after init() was
# called. The state of sensors and actuators is reset
# automatically by ARGoS.
function reset() {
   # put your code here
}



# This function is executed only once, when the robot is removed
# from the simulation
function destroy() {
   # put your code here
}

# Some random code
	

# Iteration (rid is the neighbor's id)
#neighbors.foreach(
#  function(rid, data) {
#    log("robot ", rid, ": ",
#        "distance  = ", data.distance, ", ",
#        "azimuth   = ", data.azimuth, ", ",
#        "elevation = ", data.elevation) 
#})
 
# Transformation
#cart = neighbors.map(
#  function(rid, data) {
#    var c = {}
#    c.x = data.distance * math.cos(data.elevation) * math.cos(data.azimuth)
#    c.y = data.distance * math.cos(data.elevation) * math.sin(data.azimuth)
#    c.z = data.distance * math.sin(data.elevation)
#   return c
# })
 
# Reduction (accum is a table)
# with values x, y, and z, initialized to 0
#result = cart.reduce(function(rid, data, accum) {
#    accum.x = accum.x + data.x
#    accum.y = accum.y + data.y
#    accum.z = accum.z + data.z
#    return accum
#  }, {.x=0, .y=0, .z=0})
 
# Filtering
#onemeter = neighbors.filter(function(rid, data) {
    # We assume the distance is expressed in centimeters
#    return data.distance < 100 })
#log(cart.count())
#log(result.x)
#log (onemeter)
#function orientToGlobal2DPoint(point.x, point.y){
#	if(pose.orientation.yaw !=)
#}

#function goTo2DPoint(point.x, point.y){
